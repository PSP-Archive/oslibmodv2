<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__main__memory.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory<div class="ingroups"><a class="el" href="group__main.html">Main</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaac62fc853a69d2f3a2d07c4afcfb33aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gaac62fc853a69d2f3a2d07c4afcfb33aa">oslUncacheData</a>(data, size)&#160;&#160;&#160;sceKernelDcacheWritebackInvalidateRange(data, size);</td></tr>
<tr class="separator:gaac62fc853a69d2f3a2d07c4afcfb33aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c3ace53936b45bcb86d36935ac01c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga49c3ace53936b45bcb86d36935ac01c5">oslGetUncachedPtr</a>(adr)&#160;&#160;&#160;((void*)((int)(adr)|0x40000000))</td></tr>
<tr class="separator:ga49c3ace53936b45bcb86d36935ac01c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204d2c76e11ccd5f70a0b7f925566aa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga204d2c76e11ccd5f70a0b7f925566aa3">oslGetCachedPtr</a>(adr)&#160;&#160;&#160;((void*)((int)(adr)&amp;(~0x40000000)))</td></tr>
<tr class="separator:ga204d2c76e11ccd5f70a0b7f925566aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2272bf44bae6ed8f27e3a60b7226dcbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga2272bf44bae6ed8f27e3a60b7226dcbe">sceDmacMemcpy</a> (void *dest, const void *source, unsigned int size)</td></tr>
<tr class="separator:ga2272bf44bae6ed8f27e3a60b7226dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1557c9b83879112e2a4c3a1af791652a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga1557c9b83879112e2a4c3a1af791652a">sceDmacTryMemcpy</a> (void *dest, const void *source, unsigned int size)</td></tr>
<tr class="separator:ga1557c9b83879112e2a4c3a1af791652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad161d625f2ace18ca2e9847c87b264d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gad161d625f2ace18ca2e9847c87b264d1">oslFasterMemset</a> (u64 *dst, u64 *src, u32 length)</td></tr>
<tr class="separator:gad161d625f2ace18ca2e9847c87b264d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dd77badbdd48d26032b524afc3bd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga61dd77badbdd48d26032b524afc3bd18">oslFlushDataCache</a> ()</td></tr>
<tr class="separator:ga61dd77badbdd48d26032b524afc3bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1c0668b7069bb45fd6e69f301ed5b9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga6a1c0668b7069bb45fd6e69f301ed5b9">memalign</a> (size_t alignment, size_t size)</td></tr>
<tr class="separator:ga6a1c0668b7069bb45fd6e69f301ed5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f51609a9d0f7a1b34d73912e83b01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a> ()</td></tr>
<tr class="separator:gac8f51609a9d0f7a1b34d73912e83b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains routines about memory (cache, copy, etc.). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaac62fc853a69d2f3a2d07c4afcfb33aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslUncacheData</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;sceKernelDcacheWritebackInvalidateRange(data, size);</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine will make sure that the data will no more reside in the CPU cache. The CPU does automatically put data in cache when you want to read or write to it, making subsequent accesses faster (because the cache is way faster than conventional RAM). The problem is that if the GE (graphic processor) for example wants to access it, it will read the real memory, and thus if some data is still sitting in the cache (not written to actual RAM yet) the GE will get incorrect data, making it crash or display corrupt graphics.</p>
<p>To avoid problems, you can either bypass the cache by writting to uncached addresses (oslGetUncachedPtr) or by flushing the data from cache before sending them to the GE (or DMA). This function, oslUncacheData, will flush the actual data from cache, writing it to real memory. This does take some time so don't abuse and call it only when necessary. </p><pre class="fragment">    \param data
            Adress of the memory area to flush.
    \param size
            Size (in bytes) of the area.
</pre><p>Uncaching should be done after you've accessed raw image / palette / something contents. This includes oslSetImagePixel and accesses to the raw image data pointed to by <a class="el" href="struct_o_s_l___i_m_a_g_e.html#a97a8aa1856d84160efd66e51fdf3f797" title="Raw image data in memory. ">OSL_IMAGE::data</a>.</p>
<p>Note: There are specific functions to uncache palettes and images, simplier to use. You should rather use them instead. </p>

</div>
</div>
<a class="anchor" id="ga49c3ace53936b45bcb86d36935ac01c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetUncachedPtr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr</td><td>)</td>
          <td>&#160;&#160;&#160;((void*)((int)(adr)|0x40000000))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to an uncached address. In this case, cache will be bypassed and you'll not have to call oslUncache[something] after modifying data. However performance is usually worse and caching is a good thing, so do it if you know what you are doing.</p>
<p>Important: NEVER mix cached and uncached addresses when accessing somewhere. Either always access them as cached or unached. If you mix them some weird bugs may appear because you could for example write directly in memory bypassing the cache, but some data is still sitting in the cache. So, once the cache is full, data will be flushed and written to the memory, replacing the data you wrote in an uncached way. You will not understand why your data gets corrupted, and as this will maybe happen seconds later in special circumstances, so it will be impossible to detect or debug. </p>

</div>
</div>
<a class="anchor" id="ga204d2c76e11ccd5f70a0b7f925566aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetCachedPtr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr</td><td>)</td>
          <td>&#160;&#160;&#160;((void*)((int)(adr)&amp;(~0x40000000)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to cached data. Same remark as above. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2272bf44bae6ed8f27e3a60b7226dcbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sceDmacMemcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies data using the internal DMAC. Should be faster than a memcpy, but requires that data to be copied is no more in the cache, so usually you should issue a oslUncacheData on the source and destination addresses else very strange bugs may happen. </p>

</div>
</div>
<a class="anchor" id="ga1557c9b83879112e2a4c3a1af791652a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sceDmacTryMemcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as sceDmacMemcpy. </p>

</div>
</div>
<a class="anchor" id="gad161d625f2ace18ca2e9847c87b264d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslFasterMemset </td>
          <td>(</td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does a memset using the 64-bit capabilities of the CPU. Faster than memcpy. </p>

</div>
</div>
<a class="anchor" id="ga61dd77badbdd48d26032b524afc3bd18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslFlushDataCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes the whole cache. This is slow, absolutely avoid it! Use oslUncacheData instead if possible. </p>

</div>
</div>
<a class="anchor" id="ga6a1c0668b7069bb45fd6e69f301ed5b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memalign </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a memory block, ensuring it is aligned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>Alignment in bytes </td></tr>
    <tr><td class="paramname">size</td><td>Size of the block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8f51609a9d0f7a1b34d73912e83b01d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> oslGetRamStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets info about currently available memory in main RAM. The return value is a <a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> structure which contains info about available memory.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">//You can either store the result to a structure and access its members</span></div>
<div class="line"><a class="code" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> ram = <a class="code" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a>();</div>
<div class="line"><a class="code" href="group__msgbox.html#ga38ea43b36a7f4b5c03b492dd7edaa843">oslDebug</a>(<span class="stringliteral">&quot;%i bytes available&quot;</span>, ram.<a class="code" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html#a13505b3121233ca59bdeed48398d3048">maxAvailable</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">//Or directly use the return value from the function, like this</span></div>
<div class="line"><a class="code" href="group__msgbox.html#ga38ea43b36a7f4b5c03b492dd7edaa843">oslDebug</a>(<span class="stringliteral">&quot;%i bytes available&quot;</span>, <a class="code" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a>().maxAvailable);</div>
</div><!-- fragment --><p><b>Note:</b> About the example above, just notice that each call to oslGetRamStatus costs a lot of time, so if you need to retrieve several results (e.g. both maxAvailable and maxBlockSize) you should not use the second method as it will need two calls to oslGetRamStatus. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
